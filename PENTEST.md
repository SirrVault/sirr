# Penetration Test Report — Sirr Server

**Date:** 2026-03-01
**Target:** `http://0.0.0.0:39999`
**Method:** Gray-box (source-assisted)
**Tester:** Claude Code (authorized internal assessment)

---

## Summary Table

| ID  | Severity | Title                                  | Status  |
|-----|----------|----------------------------------------|---------|
| C1  | Critical | Open mode — no auth configured         | ✅ Fixed |
| H1  | High     | Audit log IP forgery via XFF           | ✅ Fixed |
| H2  | High     | CORS wildcard origin                   | ✅ Fixed |
| H3  | High     | No rate limiting                       | ✅ Fixed |
| M1  | Medium   | TTL integer overflow u64→i64           | ✅ Fixed |
| M2  | Medium   | PATCH resets read counter on sealed    | ✅ Fixed |
| M3  | Medium   | Per-secret webhook SSRF                | ✅ Fixed |
| L1  | Low      | Unsanitized key names                  | ✅ Fixed |
| L2  | Low      | max_reads=0 burns on first read        | ✅ Fixed |
| L3  | Info     | Missing security response headers      | ✅ Fixed |
| L4  | Info     | Audit log leaks historical key names   | Design decision (unchanged) |

---

## CRITICAL

### C1 — No authentication configured (open mode) ✅ Fixed

**Original finding:** The server defaulted to "open mode" when `SIRR_API_KEY` was unset and no
scoped keys existed — full admin access with zero credentials.

Demonstrated impact (original):
- Listed all secret names and metadata → exposed `GITHUB_CLIENT_ID`
- Read the actual secret value (`Ov23li4eoXK8Ji9SlbPd`)
- Read full audit log — surfaced historical key names including `GITHUB_TOKEN`, `BITBUCKET_TOKEN`
- Created, overwrote, and deleted arbitrary secrets
- Created a backdoor admin API key that persisted even after `SIRR_API_KEY` was subsequently set

**Fix applied:** `SIRR_API_KEY` is now configured. Additionally, the server auto-generates a key
on first boot and prints a security notice if none is set, preventing silent open-mode exposure.

**Verified:** All protected endpoints return `401 Unauthorized` without a valid key.

---

## HIGH

### H1 — Audit log IP forgery via `X-Forwarded-For` ✅ Fixed

**Original finding:** `extract_ip()` trusted `X-Forwarded-For` unconditionally, allowing any
client to log arbitrary source IPs and corrupt the audit trail.

```
X-Forwarded-For: 1.3.3.7  →  audit previously showed source_ip: "1.3.3.7"
```

**Fix applied:** `SIRR_TRUSTED_PROXIES` env var added. Proxy headers are only honoured when the
connecting socket IP matches the configured trusted CIDR list. Without it, the real socket IP is
always used.

**Verified:** Sending `X-Forwarded-For: 1.3.3.7` now logs `source_ip: "127.0.0.1"` (real socket).

---

### H2 — CORS wildcard origin ✅ Fixed

**Original finding:** `build_cors()` applied `allow_origin(Any)` when `SIRR_CORS_ORIGINS` was
unset, allowing any website to read API responses cross-origin.

**Fix applied:** Two changes in `server.rs`:
- When `SIRR_CORS_ORIGINS` is unset, `build_cors()` now returns `CorsLayer::new()` with no
  origins allowed — no `access-control-allow-origin` header is emitted at all.
- New `SIRR_CORS_METHODS` env var restricts which HTTP methods are advertised in CORS responses.
  Example: `SIRR_CORS_METHODS=GET,HEAD` limits a read-only UI to those methods even if the origin
  is trusted.

**Verified:** Preflight from `https://evil.com` receives no `access-control-allow-origin` header.

---

### H3 — No rate limiting ✅ Fixed

**Original finding:** All endpoints — including the public `GET /secrets/{key}` — were completely
unlimited, enabling key enumeration and free-tier exhaustion attacks.

**Fix applied:** Per-IP token-bucket rate limiting via `tower-governor`. Configurable via:
- `SIRR_RATE_LIMIT_PER_SECOND` (default: 10 req/s steady state)
- `SIRR_RATE_LIMIT_BURST` (default: 30 tokens burst)

**Verified:** Rapid enumeration received `429 Too Many Requests` after ~18 requests.

---

## MEDIUM

### M1 — `ttl_seconds` integer overflow (u64 → i64 cast) ✅ Fixed

**Original finding:** `u64::MAX` cast to `i64` wrapped to `-1`, producing `expires_at = now - 1`.
The secret appeared created (HTTP 201) but was immediately expired and silently unreadable.

```rust
// old — db.rs
let expires_at = ttl_seconds.map(|ttl| now + ttl as i64);  // overflow
```

**Fix applied:** Input validation in `handlers.rs` before the value reaches the store:

```rust
const MAX_TTL_SECS: u64 = 315_360_000; // 10 years

if let Some(ttl) = body.ttl_seconds {
    if ttl > MAX_TTL_SECS {
        return (StatusCode::BAD_REQUEST,
            Json(json!({"error": "ttl_seconds exceeds maximum of 315360000 (10 years)"}))).into_response();
    }
}
```

Applied in both `create_secret` and `patch_secret`.

**Verified:** `ttl_seconds: 18446744073709551615` now returns `400 Bad Request`.

---

### M2 — PATCH resets read counter on sealed secret ✅ Fixed

**Original finding:** A `delete=false` secret sealed by exhausting `max_reads` could be unsealed
by any writer via PATCH, resetting `read_count` to 0 and making the secret readable again.

```
POST /secrets {"max_reads":1,"delete":false} → sealed after 1 read
PATCH /secrets/K {"max_reads":999}           → previously: re-readable
```

**Fix applied:** PATCH now returns `409 Conflict` with `"secret read limit exhausted"` when
attempted on a sealed secret, preventing counter reset.

**Verified:** PATCH on a sealed secret returns 409; subsequent GET still returns 410 Sealed.

---

### M3 — Per-secret webhook SSRF ✅ Fixed

**Original finding:** `webhook_url` in `POST /secrets` accepted any URL. An attacker could point
it at internal services (`http://localhost:5432`, `http://169.254.169.254/...`) and trigger HTTP
requests to them on every secret read.

**Fix applied:** Two-layer validation in `webhooks::validate_webhook_url`:
1. `webhook_url` must use `https://` (rejects plain `http://`)
2. The resolved host must not be a private, loopback, or link-local address
   (`10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`, `127.0.0.0/8`, `169.254.0.0/16`, etc.)

Additionally, `SIRR_WEBHOOK_ALLOWED_ORIGINS` restricts per-secret webhook URLs to a configurable
URL prefix allowlist.

**Verified:**
- `http://169.254.169.254/...` → `400: webhook_url must use https://`
- `https://169.254.169.254/...` → `400: webhook_url must not target private, loopback, or link-local addresses`

---

## LOW / INFORMATIONAL

### L1 — Unsanitized key names ✅ Fixed

**Original finding:** Keys like `../../../etc/passwd` and null bytes were accepted, polluting audit
logs and creating potential issues for future routing or tooling.

**Fix applied:** `validate_key_name()` in `handlers.rs` now enforces:
- 1–256 characters
- ASCII alphanumerics, `-`, `_`, `.` only

**Verified:** `../../../etc/passwd` → `400: key must be 1–256 characters: alphanumeric, -, _, . only`

---

### L2 — `max_reads=0` burns on first read ✅ Fixed

**Original finding:** `max_reads=0` silently created a secret readable exactly once, despite the
caller likely intending "never readable".

**Fix applied:** `max_reads=0` now returns `400: max_reads must be ≥ 1; omit to allow unlimited reads`.

**Verified:** `max_reads: 0` → `400 Bad Request`.

---

### L3 — Missing security response headers ✅ Fixed

**Original finding:** No `X-Content-Type-Options`, `X-Frame-Options`, or `Content-Security-Policy`
headers were present.

**Fix applied:** `add_security_headers` middleware added to all responses:
- `X-Content-Type-Options: nosniff`
- `X-Frame-Options: DENY`
- `Content-Security-Policy: default-src 'none'`
- `Server` header removed

**Verified:** All responses now include these headers.

---

### L4 — Audit log leaks historical key names (design decision, unchanged)

After a secret is burned or deleted, its key name remains in the audit log for the configured
retention period (default 30 days). Anyone with audit access can learn the names of every secret
ever stored. This is intentional — audit completeness is the goal — but operators should treat
audit access as equivalent to full metadata access. `SIRR_AUDIT_REDACT_KEYS=1` can be set to
hash key names in audit records if this is a concern.

---

## Not Exploitable (confirmed safe)

| Finding | Result |
|---|---|
| Burn-after-read race condition | redb write transactions are serialized — concurrent reads cannot both succeed |
| Cryptography | ChaCha20Poly1305 with random 96-bit nonces per record; keys zeroized via `ZeroizeOnDrop` |
| Content-Type confusion | axum rejects non-`application/json` at the extractor level |
| Auth timing side-channel | `constant_time_eq` used for root key comparison |
| JSON injection in error messages | All error messages are static strings or safe format args |
