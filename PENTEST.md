# Penetration Test Report — Sirr Server

**Date:** 2026-03-01
**Target:** `http://0.0.0.0:39999`
**Method:** Gray-box (source-assisted)
**Tester:** Claude Code (authorized internal assessment)

---

## CRITICAL

### C1 — No authentication configured (open mode)

The server was running without `SIRR_API_KEY` set and no scoped keys existed at startup. This puts
the server into "open mode" — **full admin access with zero credentials** for anyone who can reach
the port.

Demonstrated impact:
- Listed all secret names and metadata → exposed `GITHUB_CLIENT_ID`
- **Read the actual secret value** (`Ov23li4eoXK8Ji9SlbPd`)
- Read full audit log — surfaced historical key names including `GITHUB_TOKEN`, `BITBUCKET_TOKEN`
- Created, overwrote, and deleted arbitrary secrets
- Created a backdoor API key with admin permissions — this persists access *even after*
  `SIRR_API_KEY` is later set, because scoped keys are checked independently

**Remediation:** Set `SIRR_API_KEY` before exposing on any network. Or bootstrap scoped keys
immediately after first run via `POST /keys` while still on localhost.

---

## HIGH

### H1 — Audit log IP forgery via `X-Forwarded-For`

`extract_ip()` in `handlers.rs:41` trusts `X-Forwarded-For` unconditionally. Any client can
claim any source IP, destroying the forensic value of the audit trail.

```
# Both of these were logged with the spoofed IP:
X-Forwarded-For: 1.3.3.7            → audit: source_ip "1.3.3.7"
X-Forwarded-For: 192.168.1.1, 10.0.0.1  → audit: source_ip "192.168.1.1"
```

**Remediation:** Only trust `X-Forwarded-For` when the request originates from a known trusted
proxy CIDR. Otherwise fall through to the real socket IP. Consider a `SIRR_TRUSTED_PROXIES`
env var.

---

### H2 — CORS allows any origin (`access-control-allow-origin: *`)

When `SIRR_CORS_ORIGINS` is unset, `build_cors()` in `server.rs:360` applies `allow_origin(Any)`.
Any web page — including malicious third-party sites — can make cross-origin requests to the API
and read the responses. If the server is reachable from a user's browser (LAN, VPN, or public
internet), this enables full secret exfiltration from a drive-by page.

**Remediation:** Set `SIRR_CORS_ORIGINS=https://your-ui.example.com`. Default should be deny-all,
not allow-all.

---

### H3 — No rate limiting on any endpoint

`GET /secrets/{key}` is always public and receives no rate limiting. An attacker can:

- Enumerate secret key names at full network speed (no backoff, no lockout, no captcha)
- Hammer a burn-once secret with concurrent reads trying to win a timing window
- Submit secrets in a loop to hit the free-tier limit and deny service to the legitimate owner

**Remediation:** Add per-IP rate limiting (e.g. `tower-governor`) on public endpoints. At minimum
rate-limit the GET endpoint; ideally all endpoints.

---

## MEDIUM

### M1 — `ttl_seconds` integer overflow (u64 → i64 cast)

```rust
// store/db.rs:92
let expires_at = ttl_seconds.map(|ttl| now + ttl as i64);
```

`u64::MAX` (18446744073709551615) cast to `i64` wraps to `-1`, so `expires_at = now - 1`. The
secret is created successfully but is immediately expired and unreadable — silently. A client
supplying a very large TTL believing they are setting a far-future expiry gets a secret that
disappears instantly.

**Remediation:** Validate `ttl_seconds` before the cast:
- Reject or cap values above a reasonable maximum (e.g. `315360000` — 10 years in seconds)
- Or use `i64::try_from(ttl)` and return a 400 on overflow

---

### M2 — PATCH resets read counter, defeating sealed-secret intent

A secret with `delete=false` and `max_reads=1` is sealed after one read. However, any caller with
write permission can PATCH it with a new `max_reads` value — which also resets `read_count` to 0
— making the secret readable again indefinitely.

```
POST /secrets  {"key":"K","value":"V","max_reads":1,"delete":false}
GET  /secrets/K  → 200 (sealed after this)
GET  /secrets/K  → 410 Sealed
PATCH /secrets/K {"max_reads":999}  → 200 (read_count reset to 0)
GET  /secrets/K  → 200 (readable again!)
```

This is by design (PATCH is the unsealing mechanism), but it means `delete=false` + `max_reads`
provides no read-count guarantee if the writer and reader share a trust boundary.

**Remediation:** Document this explicitly. If one-time-read is a security property, either
disallow PATCH on sealed secrets, or require a separate admin-level permission to PATCH.

---

### M3 — Per-secret webhook URL stored without SSRF validation

`POST /secrets` accepts a `webhook_url` field. When that secret is subsequently read, the server
POSTs to that URL (if `SIRR_WEBHOOK_SECRET` is configured). The URL receives no validation beyond
what `reqwest` applies. A writer can point this at internal services (`http://localhost:5432`,
`http://10.0.0.1/admin`, cloud metadata endpoints, etc.) and use secret reads as a trigger to
probe the internal network.

**Remediation:**
- Validate webhook URLs against a configurable allowlist, or
- Restrict `webhook_url` creation to admin-permission keys only, or
- Block private/link-local IP ranges in the webhook client (`169.254.0.0/16`, `10.0.0.0/8`, etc.)

---

## LOW / INFORMATIONAL

### L1 — Secret key names are not sanitized

Keys such as `../../../etc/passwd` are accepted and stored (confirmed working). While redb is a
key-value store so no path traversal occurs at the storage layer, these keys appear verbatim in
audit logs, `GET /secrets` listings, and any downstream tooling. Future routing or UI changes
could introduce issues.

**Remediation:** Restrict key characters to a safe subset (e.g. `[A-Za-z0-9._/:-]`) or at minimum
reject null bytes and control characters.

---

### L2 — `max_reads=0` silently creates a burn-on-first-read secret

With `max_reads=0`, `is_burned()` returns true immediately (`0 >= 0`). The first `GET` both
returns the value *and* burns the record. A caller intending "never readable" gets a secret that
is readable exactly once. No error is returned on creation.

**Remediation:** Either reject `max_reads=0` with a 400, or document that 0 means "burn on
first read" rather than "never readable".

---

### L3 — No security response headers

The API returns no `X-Content-Type-Options`, `X-Frame-Options`, or `Content-Security-Policy`
headers. Minor for a JSON API, but worth adding via a `tower_http::set_header` layer if a browser
UI ever shares the origin.

---

### L4 — Audit log permanently records deleted secret names

After a secret is burned or deleted, its key name remains in the audit log indefinitely (default
retention: 30 days). Anyone with access to `GET /audit` can learn the names of every secret ever
stored, including those the owner believed were ephemeral.

**Remediation:** Consider redacting or hashing key names in audit events, or document that audit
access is equivalent to metadata access for all historical secrets.

---

## Not Exploitable (confirmed safe)

| Finding | Result |
|---|---|
| Burn-after-read race condition | redb write transactions are serialized — concurrent reads cannot both succeed |
| Cryptography | ChaCha20Poly1305 with random 96-bit nonces per record; keys zeroized via `ZeroizeOnDrop` |
| Content-Type confusion | axum rejects non-`application/json` at the extractor level (422) |
| Auth timing side-channel | `constant_time_eq` used for root key comparison |
| JSON injection in error messages | All error messages are static strings or safe format args |

---

## Summary Table

| ID  | Severity | Title                                  | Effort to Fix |
|-----|----------|----------------------------------------|---------------|
| C1  | Critical | Open mode — no auth configured         | Low (set env var) |
| H1  | High     | Audit log IP forgery via XFF           | Medium |
| H2  | High     | CORS wildcard origin                   | Low (set env var) |
| H3  | High     | No rate limiting                       | Medium |
| M1  | Medium   | TTL integer overflow u64→i64           | Low |
| M2  | Medium   | PATCH resets read counter on sealed    | Low (docs or guard) |
| M3  | Medium   | Per-secret webhook SSRF                | Medium |
| L1  | Low      | Unsanitized key names                  | Low |
| L2  | Low      | max_reads=0 burns on first read        | Low |
| L3  | Info     | Missing security response headers      | Low |
| L4  | Info     | Audit log leaks historical key names   | Design decision |
